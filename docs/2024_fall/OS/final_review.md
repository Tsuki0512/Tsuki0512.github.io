# 操作系统期末复习

*参考笔记：[Isshiki修's Notebook](https://note.isshikih.top/cour_note/D3QD_OperatingSystem/Unit0/)*

## 0 - Overview

### 0.1 操作系统定义

- 职能角度 - 资源管理
- 存在角度 - 管理用户程序的软件程序，kernel是计算机开机后一直在运行的程序

### 0.2 操作系统评价方式

1. 可靠性 - 异常处理机制
2. 安全性 - 权限管理机制 - 不同权限模式
3. 易用性 - 系统调用机制
      - 命令接口、程序接口、图形用户接口、命令行接口...
4. 高效性 - 任务执行机制 - 分时系统实现体感上的并行
5. 公平性 - 进程管理机制 - 避免饥饿现象
6. 可拓展性、易维护性等开发者角度

### 0.3 操作系统架构

- 单处理器系统 - 有且仅有一个单核的通用处理器（可以有别的不运行线程的专用处理器）
- 多处理器系统 - 多个单核的通用处理器 - 吞吐量提升，但非线性提升
- 集群系统 - 多个独立的计算机系统作为节点，通过冗余实现高可用服务，通过并行实现高性能计算
    - 对称集群 - 各个节点互相监督
    - 不对称集群 - 替补关系

### 0.4 操作系统任务处理

- 批处理系统：成批、串行，交互性差
    - 单道批处理阶段 - 同一时间一个任务，会导致CPU长时间空闲
    - 多道批处理阶段 - 宏观上并发，微观上串行
- 分时系统：“体感上”并行，按照时间片进行进程间切换
- 实时系统：特定时间完成特定任务
- 分布式系统：多台计算机共同完成一个任务

### 0.5 操作系统结构设计

有中心：

- 宏内核：耦合所有主要功能，效率高，可靠性低
- 微内核：只提供最基本功能，可靠性高，可拓展性高

*混合系统结合了宏内核和微内核的设计思路。*

分层网状：

- 分层设计：类似计网，$i$用$i-1$层接口，开发维护方便，但逐层接口调用导致效率受限
- 模块化设计：非递进式，将操作系统划分成独立模块

### 0.6 操作系统运行原理

引导 $\to$ 用户态 |（中断（计时器）、系统调用）| 内核态

中断：

- 从紧急程度：可屏蔽中断、不可屏蔽中断
- 从触发原因：内中断（异常等程序导致的）、外中断（硬件产生）

## 1 - Process Management

*进程是资源分配和管理的独立单位*

### 1.1 进程基本概念

#### 1.1.1 进程的形式

- 内核态虚拟内存 - 元数据（进程控制块PCB）

      - ![image-20241127232049530](./markdown-img/final_review.assets/image-20241127232049530.png) 

- 用户态虚拟内存 - 实际需要的数据资源

    ![image-20241209211633935](./markdown-img/final_review.assets/image-20241209211633935.png)
    
- 静态部分
    - text section - 代码
    - data section - 进程全局变量、静态变量
- 动态更新部分
    - heap - 被动态分配的内存
    - stack - 暂时性数据，函数传参、返回值等

#### 1.1.2 进程的状态

进程的状态和转换关系：

![image-20241209212059494](./markdown-img/final_review.assets/image-20241209212059494.png)

实现调度需要维护等待队列（可能有多个）和就绪队列：

![image-20241209212245180](./markdown-img/final_review.assets/image-20241209212245180.png)

### 1.2 进程管理

#### 1.2.1 创建 - `fork()`

1. 复制父进程数据，即直接`fork`
2. 载入新程序并继续执行，`fork`后`execXX()`

相关技术：COW、`vfork()`

#### 1.2.2 终止 - `exit()`

子进程通过`exit()`终止之后（僵尸进程）需要父进程的`wait()`去回收资源，如果此时父进程被终止则变成孤儿进程，交由`init/systemd`来`wait()`或通过级联终止来避免。

#### 1.2.3 通信

- 信号量
- 共享内存 - 通过系统调用建立，更快
- 信息传递 - 不需要处理数据冲突，少量有用，分布式系统更容易实现
- 文件/管道（本质上也是一种文件，单向传输）

### 1.3 进程调度

- 调度分类
    - 抢占式 - 不占有资源的进程索取cpu资源
    - 非抢占式 - 已拥有资源的进程主动释放cpu资源
- 调度过程 - `__switch_to`
    1. 上下文切换 - 寄存器、进程状态、管理信息
    2. `sret`回用户态`sepc`
- 调度算法指标
    - cpu使用率
    - 吞吐量 - 单位时间内完成的进程数
    - 周转时间 -开始建立 $\to$ 进程完成
    - 等待时间 - = 周转时间 - 运行时间
    - 响应时间 - 发出请求 $\to$ 第一次响应
- 调度算法
    - FCFS - 非抢占式、实现简单
    - SJF - 非抢占式、平均等待时间最小，会导致饥饿现象且运行时间不好预估
    - SRTF - 抢占式（剩余运行时间最短）、平均等待时间最小，会导致饥饿现象且运行时间不好预估
    - RR - 抢占式、解决饥饿现象，频繁切换会导致较高的dispatch latency
    - priority scheduling - 和SJF/SRTF一样分成抢占式和非抢占式两种，会导致饥饿现象
        - priority aging - 避免饥饿现象，优先级随着等待时间不断增长
- 调度设计
    - multilevel queue scheduling - 队列间根据优先级抢占式调度，队列内根据需求采取不同的调度算法
    - multilevel feedback queue scheduling - 允许进程在队列间转移（占有太久cpu -- 优先级`--`；等待太久 -- 优先级`++`）

### 1.4 线程

定义：进程内可调度的执行单元

目的：减小fork和切换的开销

进程间线程共享静态资源，各自维护必需的动态资源：便于线程间通信、任务粒度小减少响应时间；进程内出问题会影响所有线程、内存保护问题。

多线程模型：

- 用户级多线程：支持更多线程数，更容易自定义线程调度算法
- 内核级多线程：单线程阻塞不导致整个进程阻塞，可以利用多核实现并行
- 关系（用户-内核）：一对一、多对多、多对一

## 2 同步

## 3 内存
